# 深さ優先探査

## 概要

深さ優先探索とは，グラフ上を全探索する方法のうちの1つです．

ただしここで言うグラフとはグラフ理論のグラフです．

## グラフとは

「そもそもグラフってなに？」という人も多いと思います．

(グラフ理論の)グラフとは「頂点」とそれらを結ぶ「辺」からなる構造です。

競技プログラミングではこのような構造において最短経路を求めたり，任意の頂点からまた別の頂点に辿り着けるかという問題がよく出ます。

このような問題を解決出来るのが今回解説するDFSなどです。

## 深さ優先探索の仕組み

深さ優先探索は次のような手順で探索していきます．

1. 今見ている頂点から進めるだけ進む
2. 突き当たりまで辿り着いたら１つ戻る
3. 進める頂点に進む
4. 1に戻る

DFSはこの手順を見たことがない頂点が無くなるまでor進めるところが完全に無くなるまで繰り返すことで探索します．

各頂点を調べること自体は1回ずつしか行わないため，計算量はO(V) (ただしVは頂点数)です．

## 深さ優先探索の実装方法

実装には再帰関数を用いるものと、スタックを使うものの2種類あります。

それぞれ得意不得意がありますが、再帰関数を用いた方法の方がよく見るような気がするので、ここでは再帰関数を用いて実装します。(スタックを用いた実装についてはBFSの回で少し触れます)

次の問題を解いてみます。

[問題文](https://hackmd.io/@kcctkyopro/BkeWngHss)

# DFS

実行時間制限:2sec/メモリ制限:1024MB

予想diff:250~350

## 問題文
頂点に$1$から$N$までの番号が、辺に$1$から$M$までの番号がついた単純無向グラフが与えられます。辺$i$は頂点$u_i$と$v_i$を結んでいます。

頂点$s$から$0$個以上の頂点を通って頂点$g$にたどり着けるかを判定してください。

## 制約

* $1 \leq N \leq 2 \times 10^5$

* $1 \leq M \leq \mathrm{min}\left(2\times 10^5 , \frac{N\left(N-1\right)}{2}\right)$

* $1 \leq u_i < v_i \leq N$

* $u_i$は互いに異なる

* $v_i$は互いに異なる

* $1 \leq s,g \leq N$

* $s \neq g$

入力はすべて正の整数

## 入力

入力は以下の形式で標準入力から与えられる。

```
N M
u_1 v_1
u_2 v_2
...
u_M v_M
s g
```

## 出力

頂点$s$から$0$個以上の頂点を通って頂点$g$にたどり着ける場合は```Yes```、そうでない場合は```No```を出力してください。

## 入力例1

```
6 5
1 2
2 3
1 3
3 6
4 5
1 6
```

## 出力例1

```
Yes
```

頂点1→3→6と行くことでたどり着けます。

## 入力例2

```
6 5
1 2
2 3
1 3
3 6
4 5
5 2
```

## 出力例2

```
No
```

頂点2からどのように移動しても頂点5にはたどり着けません。

## 解説

この問題の入力例1,2のグラフは以下のようになっています。

```
graph TD

a((1))---b((2))---c((3))

c---a

c---d((6))

e((4))---f((5))
```

## 草案

このグラフは以下の方法で探索すると良いです。

1. 頂点$s$を読み取る
2. 読み込んだ頂点からたどり着ける頂点を確認する、たどり着ける頂点がなければ一つ前の頂点に戻る
3. たどり着ける頂点が頂点$g$ならその場で探索終了、そうでなければその頂点を読み込む
4. 移動できる頂点がなくなるまで2と3を繰り返す

実装例を示します。

```
#include<bits/stdc++.h>
using namespace std;

void DFS(int now,int gorl,vector<vector<int>> &G,vector<bool> &flag){
    flag[now]=true;
    if(flag[gorl])return;
    for(auto x:G[now]){
        if(!flag[x]){
            DFS(x,gorl,G,flag);
        }
    }
}

int main(){
    int N,M;
    cin>>N>>M;
    vector<vector<int>> G(N);
    vector<bool> flag(N,false);
    int u,v;
    for(int i=0;i<M;i++){
        cin>>u>>v;
        u--;v--;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    int s,g;
    cin>>s>>g;
    s--;g--;
    DFS(s,g,G,flag);
    if(flag[g]){
        cout<<"Yes"<<endl;
    }
    else{
        cout<<"No"<<endl;
    }
    return 0;
}
```


