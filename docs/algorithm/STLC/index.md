# STLコンテナクラスを用いた計算量削減(C++を扱う人向け)

この章は[APG4b AA - 3.03.STLのコンテナ](https://atcoder.jp/contests/apg4b/tasks/APG4b_aa)に書かれているコンテナの中から重要なものを抜粋し，それらについての説明と応用をする章です．

## 連想配列(map)

連想配列はキーとなるある値を渡すとそれに対応した値を高速に返してくれるコンテナです．

例えばキーである「リンゴ」を言うと「100円」と返し，「みかん」と言うと「50円」って返してくれるような感じです．

宣言や値の格納，値の取り出しは以下のように行います．

```cpp
#include<map> //連想配列用のヘッダファイル
#include<iostream>
#include<string>
using namespace std;
int main(){

    map<string,int> mp; //map<キーの型,値の型> 変数名 で宣言

    mp["リンゴ"]=100; //格納するときは 変数名[キー]=値
    mp["みかん"]=50;

    cout<<mp["リンゴ"]<<endl; //取り出すときは 変数名[キー]
    cout<<mp["みかん"]<<endl;



    return 0;
}
```

実行結果
```
100
50
```

C++の連想配列には重要な性質として次のような性質があります．

1. 初期値は0である

2. キーは重複して登録することは出来ない．

3. 配列の中身はキーが小さい順に並んでいる．

そのため，連想配列は次のような問題に強いです．

- 要素数え上げ

- 要素の削除と配列内の最大最小問題

- 重複検知

ここからは連想配列を用いてさっきの3つの問題について考えていきます． 

```
例題
空の配列vに対し，Q個のクエリが与えられます．
各クエリは以下のいずれかで与えられます．

1  x : 配列にxを追加する
2  x : 配列からxを1つ削除する．
3  x : 配列内に存在するxの数を出力する．
4    : 配列内に存在する要素の種類を出力する．
5    : 配列内で最も小さい要素を出力する．
6    : 配列内で最も大きい要素を出力する．
7  x : 配列内でx番目に小さい要素を出力する．
8  x : 配列内でx番目に大きい要素を出力する．
9  x : 配列内でx以上の要素の中で最も小さい要素を出力する．
10 x : 配列内でxよりも大きい要素の中で最も小さい要素を出力する．

これらのクエリを処理できるプログラムを作成してください．

入力
Q
T_0
T_1
...
T_Q-1

Tは
1 x
2 x
3 x
4
5
6
7 x
8 x
9 x
10 x
のいずれか

制約
Q<=2*10^5
x<=10^9
入力はすべて正の整数

実行制限時間
3sec
```

この問題はすべてのクエリを一気に実装しようとすると大変なので，いくつかのパートに分けて実装していきます．

以下のコードに追加していくことで実装していきます．

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int Q,a,x;
    cin>>Q;
    map<int,int> mp;
    for(int i=0;i<Q;i++){
        cin>>a;//各クエリの処理
        switch(a){
            case 1:
                break;
            case 2:
                break;
            case 3:
                break;
            case 4:
                break;
            case 5:
                break;
            case 6:
                break;
            case 7:
                break;
            case 8:
                break;
            case 9:
                break;
            case 10:
                break;
            default:
                break;
        }
    }
    return 0;
}
```

### 要素数え上げ(1,3,4のクエリ)

まずは要素の数についてのクエリを実装していきます．

1のクエリはキーに要素の値を，値にそのキーが何回追加されたかを保存しておくことで実装できます．

実装例

```cpp
case 1:
    cin>>x;
    mp[x]++;//連想配列は初期値0というのを利用していきなりインクリメントしている．
    break;
```

これだけで何回xが入力で出てきたかを保存しておくことが出来ます．

次に3のクエリを実装します．

1でmp[x]にxが出てきた回数をいれていたので，3のクエリはmp[x]を参照するだけで実装できます．

実装例

```cpp
case 3:
    cin>>x;
    cout<<mp[x]<<endl; 
    break;
```

最後に4のクエリを実装していきます．

連想配列ではキーは重複しないので，「要素の種類=キーの種類=連想配列の大きさ」と言い換えることが出来ます．

よってmp.size()を出力するだけで実装できます．

実装例
```cpp
case 4:
    cout<<mp.size()<<endl;
    break;
```

### 要素の削除と配列内の最大最小問題(2,5,6,7,8のクエリ)

先に5のクエリから実装していきます．

c++の連想配列の特徴として，「配列の中身はキーが小さい順に並んでいる」というものがありました．

この特徴を用いることで簡単に実装できます．

実装例

```cpp
case 5:
    auto itr=mp.begin();
    cout<<(*itr).first<<endl;
    break;
```

ここで謎の文 「auto itr=mp.begin();」というものが出てきました．

これはイテレータというもので，配列の場所を保存しておくものです．

今回の場合，mp.begin()を入れているので，このitrというイテレータは配列の先頭の部分を示していることになります．